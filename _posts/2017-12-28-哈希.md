---
layout:     post
title:      哈希
subtitle:   哈希的基本用法
date:       2017-12-28
author:     jinghaitingfeng
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - DataStruct
    
---

## 1. 哈希的概念 ##
　　散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，
散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。
散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素，
因而必须要在数据元素的存储位置和它的关键字（可用key表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，
只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用h(key)表示)。
根据设定的散列函数h(key)和处理冲突的方法将一组关键字key映像到一个有限的连续的地址区间上，并以关键字在地址区间中的像作为数据元素在表中的存储位置，
这种表便被称为散列表，这一映像过程称为散列，所得存储位置称为散列地址。
关键字、散列函数以及散列表的关系如下图所示：  
![](http://img.blog.csdn.net/20151123155511678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)  
哈希主要用于信息安全领域中的加密算法和在海量数据处理中有广泛应用。  

## 2. 哈希函数 ##
　　散列函数是从关键字到地址区间的映像。好的散列函数能够使得关键字经过散列后得到一个随机的地址，
以便使一组关键字的散列地址均匀地分布在整个地址区间中，从而减少冲突。  
常用的构造散列函数的方法有：  
（1）直接定址法  
　　取关键字或关键字的某个线性函数值为散列地址，即：h(key) = key或 h(key) = a * key + b，其中a和b为常数。  
（2）数字分析法  
　　如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，
可以从关键字中选出分布较均匀的若干位，构成哈希地址。例如，有80个记录，
关键字为8位十进制整数d1d2d3…d7d8，如哈希表长取100，则哈希表的地址空间为：00~99。
假设经过分析，各关键字中 d4和d7的取值分布较均匀，则哈希函数为：h(key)=h(d1d2d3…d7d8)=d4d7。
例如，h(81346532)=43，h(81301367)=06。相反，假设经过分析，各关键字中 d1和d8的取值分布极不均匀， 
d1 都等于5，d8 都等于2，此时，如果哈希函数为：h(key)=h(d1d2d3…d7d8)=d1d8，则所有关键字的地址码都是52，显然不可取。  
（3）平方取值法  
　　当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，
然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，
故不同关键字会以较高的概率产生不同的哈希地址。
例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。
例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，
A的内部编码为01,B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，
同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。
之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址  
（4）折叠法  
　　将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为散列地址。  
（5）除留余数法  
　　取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址，  
即：h(key) = key MOD p    p ≤ m   
假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为  
h（k）=k %  p ，其中%为模p取余运算。  
例如，已知待散列元素为（18，75，60，43，54，90，46），表长m=10，p=7，则有  
   h(18)=18 %7=4    h(75)=75% 7=5   h(60)=60 %7=4   
   h(43)=43 %7=1    h(54)=54% 7=5   h(90)=90 %7=6   
   h(46)=46 % 7=4  
此时冲突较多，为减少冲突，可取较大的m值和p值，如m=p=13，结果如下：  
   h(18)=18 %13=5    h(75)=75% 13=10   h(60)=60 % 13=8   
   h(43)=43 %13=4    h(54)=54% 13=2   h(90)=90 %13=12   
   h(46)=46 % 13=7  
（6）随机数法  
　　选择一个随机函数，取关键字的随机函数值为它的散列地址，即：
h(key) = random(key)其中random为随机函数    
(7) 举例  
　　将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如
上面的哈希值是Horner计算字符串哈希值的方法，公式为:h = s[0] · 31L–1 + … + s[L – 3] · 312 + s[L – 2] · 311 + s[L – 1] · 310  
　　举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，
所以字符串”call”的哈希值为 3045982 = 99·313 + 97·312 + 108·311 + 108·310 = 108 + 31· (108 + 31 · (97 + 31 · (99)))  
　　如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈西值来节省时间，比如，可以 获取每8-9个字符来获取哈希值：
## 3. 哈希冲突 ##
　　对不同的关键字可能得到同一散列地址，即key1 ≠ key2，而h(key1)= h(key2)，这种现象称为冲突。
具有相同函数值的关键字对该散列函数来说称作同义词。
在一般情况下，散列函数是一个压缩映像，这就不可避免地会产生冲突，因此，在创建散列表时不仅要设定一个好的散列函数，
而且还要设定一种处理冲突的方法。  
**1.拉链法**   
　　一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，
这就是拉链法。下图很清楚的描述了什么是拉链法。  
![](http://ww4.sinaimg.cn/mw690/6941baebjw1elxlt9uf2bj20cm08qdgu.jpg)  
　　图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，
该索引又指向了一个链表， 在链表中依次存储了这两个字符串。
该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，
以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，
首先是根据散列值找到等一应的链表，然后沿着链表顺序找到相应的键。  
　　实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表
而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，
这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会
比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。
如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。
所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，
如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。   
**2.线性探测法**  
　　线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，
使用大小为M的数组来保存N个键值对，
其中M>N，我们需要使用数组中的空位解决碰撞冲突。如下图所示：  
![](http://ww3.sinaimg.cn/mw690/6941baebjw1elxlt9kz8dj20ao09adgp.jpg)  
对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，
但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都
是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，
所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，
发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。
开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，
直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果：

* 命中，该位置的键和被查找的键相同  
* 未命中，键为空  
* 继续查找，该位置和键被查找的键不同。  
实现线性探测法也很简单，我们只需要两个大小相同的数组分别记录key和value。

**3.建立公共溢出区**   
　　这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，
凡是和基本表发生冲突的元素，一律填入溢出表。  

## 3. 代码实现 ##
A.以除留余数法和链地址法构造散列表：  

    #include <stdio.h>  
    #include <stdlib.h>  
      
    #define LEN 13  
      
    struct hash_node {  
        int count;  
        struct hash_node *next;  
    };  
      
    static int hash(int num)  
    {  
        return num % LEN;  
    }  
      
    static void collision(struct hash_node *vec[], int elem, struct hash_node *new)  
    {  
        if (vec[elem] == NULL)  
        vec[elem] = new;  
        else  
        {  
        new -> next = vec[elem];  
        vec[elem] = new;  
        }  
    }  
      
    static void ord_num_print(int i)  
    {  
        if (i == 1)  
        printf("the 1st element: ");  
        else if (i == 2)  
        printf("the 2nd element: ");  
        else if (i == 3)  
        printf("the 3rd element: ");  
        else   
        printf("the %dth element: ", i);  
    }  
      
    static void print_hash(struct hash_node *vec[])  
    {  
        int i;  
        struct hash_node *tmp;  
      
        for (i = 0; i < LEN; i++)  
        if (vec[i] == NULL)  
        {  
            ord_num_print(i+1);  
            printf("NULL\n");  
        }  
        else  
        {  
            ord_num_print(i+1);  
            tmp = vec[i];  
            do {  
            printf("%d ", tmp->count);  
            }while ((tmp = tmp->next) && tmp != NULL);  
            printf("\n");  
        }  
    }  
      
    static void create_hash(struct hash_node *vec[], int num)  
    {  
        FILE *fp;  
        int i, tmp, arr[num];  
        struct hash_node *p;  
      
        fp = fopen("./hash", "r");  
      
        for (i = 0; i < num; i++)  
        fscanf(fp, "%d", &arr[i]);  
      
        fclose(fp);  
      
        for (i = 0; i < num; i++) {  
        p = malloc(sizeof(struct hash_node));  
        p -> count = arr[i];  
        p -> next = NULL;  
      
        tmp = hash(arr[i]);  
        collision(vec, tmp, p);  
        }  
    }  

B.元素插入   

    void insert_hash_node(struct hash_node *vec[], int data)    
    {    
        int tmp;    
        struct hash_node *p = malloc(sizeof(struct hash_node));    
        p -> count = data;    
        p -> next = NULL;    
        
        tmp = hash(data);    
        collision(vec, tmp, p);    
    }    

C.元素删除 

    void delete_hash_node(struct hash_node *vec[], int data)    
    {    
        int elem;    
        struct hash_node *p, *tmp;    
        
        elem = hash(data);    
        if (vec[elem] == NULL) {    
        fprintf(stderr, "vec[%d] is NULL\n", elem);    
        exit(-2);    
        }    
        else    
        {    
        tmp = vec[elem];    
        while (tmp -> count != data) {    
            if (tmp -> next == NULL) {    
            fprintf(stderr, "not found %d\n", data);    
            exit(-3);    
            }    
            p = tmp;    
            tmp = tmp -> next;    
        }    
        p -> next = tmp -> next;    
        free(tmp);    
        }    
    }    

D.整体实现 

    int main(int argc, char *argv[])    
    {    
        int i, num;    
        struct hash_node *vec[LEN];    
        
        /* num, the number of integers in the ./hash file */    
        if (argc < 2) {    
        fprintf(stderr, "Usage: %s num\n", argv[0]);    
        exit(-1);    
        }    
        
        for (i = 0; i < LEN; i++)    
        vec[i] = NULL;    
            
        num = atoi(argv[1]);    
        
        printf("\tthe first times\n");    
        create_hash(vec, num);    
        print_hash(vec);    
        
        printf("\n\tthe second times\n");    
        insert_hash_node(vec, 29);    
        print_hash(vec);    
        
        printf("\n\tthe third times\n");    
        delete_hash_node(vec, 1);    
        print_hash(vec);    
        
        return 0;    
    }   

读取：19 14 23 01 68 20 84 27 55 11 10 79  
![](http://img.blog.csdn.net/20151123160308828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)