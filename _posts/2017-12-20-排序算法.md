---
layout:     post
title:      排序算法
subtitle:   排序算法整理
date:       2017-12-20
author:     jinghaitingfeng
header-img: img/post-bg-github-cup.jpg
catalog: true
tags:
    - Algorithm
    
---


## 1. 排序算法简介 ##
　　查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中。因为其实现代码较短，应用较常见。
所以在面试中经常会问到排序算法及其相关的问题。但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。  
　　一般在面试中最常考的是快速排序、归并排序、堆排序，并且经常有面试官要求现场写出这两种排序的代码。
对这两种排序的代码一定要信手拈来才行。还有插入排序、冒泡排序、堆排序、基数排序、桶排序等。
面试官对于这些排序可能会要求比较各自的优劣、各种算法的思想及其使用场景。还有要会分析算法的时间和空间复杂度。
通常查找和排序算法的考察是面试的开始，如果这些问题回答不好，估计面试官都没有继续面试下去的兴趣都没了。
所以想开个好头就要把常见的排序算法思想及其特点要熟练掌握，有必要时要熟练写出代码。

**排序算法分类**  
　　我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。排序算法大体可分为两种：  

* 比较排序，时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。
* 非比较排序，时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序

**排序算法复杂度比较**  
下表给出了常见比较排序算法的性能：  
![](http://images2015.cnblogs.com/blog/739525/201605/739525-20160503202729044-614991035.jpg)
**排序稳定性**  
　　排序算法稳定性的简单形式化定义为：如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。通俗地讲就是保证排序前后两个相等的数的相对顺序不变。  
　　对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。
需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。  
　　例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] >= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。
其次，说一下排序算法稳定性的好处。排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。
基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。 

## 2. 冒泡排序 ##
　　冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。它重复地走访过要排序的元素，依次比较相邻两个元素，
如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。
冒泡排序算法的运作如下：

* 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
* 针对所有的元素重复以上的步骤，除了最后一个。
* 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下：

    #include <stdio.h> 
    void Swap(int A[], int i, int j)
    {
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
    
    void BubbleSort(int A[], int n)
    {
        for (int j = 0; j < n - 1; j++)         // 每次最大元素就像气泡一样"浮"到数组的最后
        {
            for (int i = 0; i < n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移
            {
                if (A[i] > A[i + 1])            // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法
                {
                    Swap(A, i, i + 1);
                }
            }
        }
    }
    
    int main()
    {
        int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };    // 从小到大冒泡排序
        int n = sizeof(A) / sizeof(int);
        BubbleSort(A, n);
        printf("冒泡排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }
    
## 3. 选择排序 ##
　　选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；
然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。  
　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；
而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。
选择排序的代码如下：

    #include <stdio.h>
    void Swap(int A[], int i, int j)
    {
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
    
    void SelectionSort(int A[], int n)
    {
        for (int i = 0; i < n - 1; i++)         // i为已排序序列的末尾
        {
            int min = i;
            for (int j = i + 1; j < n; j++)     // 未排序序列
            {
                if (A[j] < A[min])              // 找出未排序序列中的最小值
                {
                    min = j;
                }
            }
            if (min != i)
            {
                Swap(A, min, i);    // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法
            }
        }
    }
    
    int main()
    {
        int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序
        int n = sizeof(A) / sizeof(int);
        SelectionSort(A, n);
        printf("选择排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }
    
选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。  
比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。 

## 4. 插入排序 ##
插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌  
![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160329094816957-1860272498.jpg)  
对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。
插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，
需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。  
具体算法描述如下：

* 从第一个元素开始，该元素可以认为已经被排序
* 取出下一个元素，在已经排序的元素序列中从后向前扫描
* 如果该元素（已排序）大于新元素，将该元素移到下一位置
* 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
* 将新元素插入到该位置后
* 重复步骤2~5  

插入排序的代码如下：  
    #include <stdio.h> 
    void InsertionSort(int A[], int n)
    {
        for (int i = 1; i < n; i++)         // 类似抓扑克牌排序
        {
            int get = A[i];                 // 右手抓到一张扑克牌
            int j = i - 1;                  // 拿在左手上的牌总是排序好的
            while (j >= 0 && A[j] > get)    // 将抓到的牌与手牌从右向左进行比较
            {
                A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移
                j--;
            }
            A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)
        }
    }
    
    int main()
    {
        int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序
        int n = sizeof(A) / sizeof(int);
        InsertionSort(A, n);
        printf("插入排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }
    
　　插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，
用于少量元素的排序（通常为8个或以下）。  

## 5. 希尔排序 ##
　　希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，
它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。
希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。  
希尔排序是基于插入排序的以下两点性质而提出改进方法的：

* 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
* 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

![](http://images2015.cnblogs.com/blog/735119/201603/735119-20160305135104830-1351755091.png)

　　希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。
然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），
可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。

    /*
        希尔插入排序过程
        a - 待排序数组
        s - 待排序的子分组序号
        delta - 增量
        len - 待排序数组长度
    */void shellInsert(int a[], int s, int delta, int len)
    {
        int temp, i, j, k;
        for (i = s + delta; i < len; i += delta)
        {
            for(j = i - delta; j >= s; j -= delta)
                if(a[j] < a[i])break;
    
            temp = a[i];
            for (k = i; k > j; k -= delta)
            {
                a[i] = a[i - delta];
            }
            a[k + delta] = temp;
        }
    }
    //使用希尔增量的排序
    void shellSort2(int a[], int len)
    {
        int temp;
        int delta;    //增量
    
        //希尔增量序列公式
        delta = len / 2;
    
        while(delta > 0)
        {
            for (int i = 0; i < delta; i++)
            {
                shellInsert(a, i, delta, len);
            }
            delta /= 2;
        }
    
    }
    //使用Hibbard增量的排序
    void shellSort(int a[], int len)
    {
        int temp;
        int delta;    //增量
    
        //Hibbard增量序列公式
        delta = (len + 1)/ 2 - 1;
    
        while(delta > 0)    //不断改变增量，对数组迭代分组进行直接插入排序，直至增量为1    {
            for (int i = 0; i < delta; i++)
            {
                shellInsert(a, i, delta, len);
            }
            delta = (delta + 1)/ 2 - 1;
        }
    }
    
**希尔排序高效的原因**  
1.为什么这个算法会起作用：  
　　开始的时候gap较大，子序列中的数据较少，所以最开始的时候算法运行较快，随着算法进行，gap 逐渐变小，
子序列中元素的个数也就越来越多，所以排序工作可能会变慢，但是由于前面已经完成了部分排序工作，
因而在很大程度上减轻了后来的工作量，于是最终总体的排序速度还是比较快的。  
2.希尔排序突破O(n^2)的原因：    
　　希尔能突破O(N^2)的界，可以用逆序数来理解：
假设我们要从小到大排序，一个数组中取两个元素如果前面比后面大，则为一个逆序，容易看出排序的本质就是消除逆序数。
可以证明对于随机数组，逆序数是O(N^2)的，而如果采用“交换相邻元素”的办法来消除逆序，每次正好只消除一个，
因此必须执行O(N^2)的交换次数，这就是为啥冒泡、插入等算法只能到平方级别的原因。
反过来，基于交换元素的排序要想突破这个下界，必须执行一些比较，交换相隔比较远的元素，
使得一次交换能消除一个以上的逆序，希尔、快排、堆排等等算法都是交换比较远的元素，只不过规则各不同罢了。
shell sort在适当的gap sequence下快的原因在于一次消除更多的逆序对以及通过gap减少重复无意义的比较。  
**希尔排序稳定性**  
　　希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，
相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。
比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和  { 5, 8, 2, 1, 6 } ，
未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，
即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。  

## 6. 归并排序 ##
  　　归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。
归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，
我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，
然后四四归并，然后是八八归并，一直下去直到归并了整个数组。
归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：

* 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
* 设定两个指针，最初位置分别为两个已经排序序列的起始位置
* 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
* 重复步骤3直到某一指针到达序列尾
*　将另一序列剩下的所有元素直接复制到合并序列尾  
![](http://images2015.cnblogs.com/blog/735119/201603/735119-20160305141645721-842642889.png)  

归并排序的代码如下：

    #include <stdio.h>
    #include <limits.h>
    
    // 分类 -------------- 内部比较排序
    // 数据结构 ---------- 数组
    // 最差时间复杂度 ---- O(nlogn)
    // 最优时间复杂度 ---- O(nlogn)
    // 平均时间复杂度 ---- O(nlogn)
    // 所需辅助空间 ------ O(n)
    // 稳定性 ------------ 稳定
    
    void Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]
    {
        int len = right - left + 1;
        int *temp = new int[len];       // 辅助空间O(n)
        int index = 0;
        int i = left;                   // 前一数组的起始元素
        int j = mid + 1;                // 后一数组的起始元素
        while (i <= mid && j <= right)
        {
            temp[index++] = A[i] <= A[j] ? A[i++] : A[j++];  // 带等号保证归并排序的稳定性
        }
        while (i <= mid)
        {
            temp[index++] = A[i++];
        }
        while (j <= right)
        {
            temp[index++] = A[j++];
        }
        for (int k = 0; k < len; k++)
        {
            A[left++] = temp[k];
        }
    }
    
    void MergeSortRecursion(int A[], int left, int right)    // 递归实现的归并排序(自顶向下)
    {
        if (left == right)    // 当待排序的序列长度为1时，递归开始回溯，进行merge操作
            return;
        int mid = (left + right) / 2;
        MergeSortRecursion(A, left, mid);
        MergeSortRecursion(A, mid + 1, right);
        Merge(A, left, mid, right);
    }
    
    void MergeSortIteration(int A[], int len)    // 非递归(迭代)实现的归并排序(自底向上)
    {
        int left, mid, right;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]
        for (int i = 1; i < len; i *= 2)        // 子数组的大小i初始为1，每轮翻倍
        {
            left = 0;
            while (left + i < len)              // 后一个子数组存在(需要归并)
            {
                mid = left + i - 1;
                right = mid + i < len ? mid + i : len - 1;// 后一个子数组大小可能不够
                Merge(A, left, mid, right);
                left = right + 1;               // 前一个子数组索引向后移动
            }
        }
    }
    
    int main()
    {
        int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 };      // 从小到大归并排序
        int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };
        int n1 = sizeof(A1) / sizeof(int);
        int n2 = sizeof(A2) / sizeof(int);
        MergeSortRecursion(A1, 0, n1 - 1);          // 递归实现
        MergeSortIteration(A2, n2);                 // 非递归实现
        printf("递归实现的归并排序结果：");
        for (int i = 0; i < n1; i++)
        {
            printf("%d ", A1[i]);
        }
        printf("\n");
        printf("非递归实现的归并排序结果：");
        for (int i = 0; i < n2; i++)
        {
            printf("%d ", A2[i]);
        }
        printf("\n");
        return 0;
    }

## 7. 堆排序 ##
　　堆排序是指利用堆这种数据结构所设计的一种选择排序算法。堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），
并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。
我们可以很容易的定义堆排序的过程：

* 由输入的无序数组构造一个最大堆，作为初始的无序区
* 把堆顶元素（最大值）和堆尾元素互换
* 把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整
* 重复步骤2，直到堆的尺寸为1

首先，实现堆排序需要解决两个问题：  
1. 如何由一个无序序列键成一个堆？  
2. 如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？  
第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。  
第二个问题，怎么调整成堆？  
　　首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，
这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。
从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：
49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下：  
![](http://images2015.cnblogs.com/blog/735119/201603/735119-20160305133553205-2143614528.png)    
![](http://images2015.cnblogs.com/blog/735119/201603/735119-20160305133644815-347392695.png) 

**代码实现** 
    
    #include <stdio.h>
    // 分类 -------------- 内部比较排序
    // 数据结构 ---------- 数组
    // 最差时间复杂度 ---- O(nlogn)
    // 最优时间复杂度 ---- O(nlogn)
    // 平均时间复杂度 ---- O(nlogn)
    // 所需辅助空间 ------ O(1)
    // 稳定性 ------------ 不稳定
    
    void Swap(int A[], int i, int j)
    {
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
    
    void Heapify(int A[], int i, int size)  // 从A[i]向下进行堆调整
    {
        int left_child = 2 * i + 1;         // 左孩子索引
        int right_child = 2 * i + 2;        // 右孩子索引
        int max = i;                        // 选出当前结点与其左右孩子三者之中的最大值
        if (left_child < size && A[left_child] > A[max])
            max = left_child;
        if (right_child < size && A[right_child] > A[max])
            max = right_child;
        if (max != i)
        {
            Swap(A, i, max);                // 把当前结点和它的最大(直接)子节点进行交换
            Heapify(A, max, size);          // 递归调用，继续从当前结点向下进行堆调整
        }
    }
    
    int BuildHeap(int A[], int n)           // 建堆，时间复杂度O(n)
    {
        int heap_size = n;
        for (int i = heap_size / 2 - 1; i >= 0; i--) // 从每一个非叶结点开始向下进行堆调整
            Heapify(A, i, heap_size);
        return heap_size;
    }
    
    void HeapSort(int A[], int n)
    {
        int heap_size = BuildHeap(A, n);    // 建立一个最大堆
        while (heap_size > 1)    　　　　　　 // 堆（无序区）元素个数大于1，未完成排序
        {
            // 将堆顶元素与堆的最后一个元素互换，并从堆中去掉最后一个元素
            // 此处交换操作很有可能把后面元素的稳定性打乱，所以堆排序是不稳定的排序算法
            Swap(A, 0, --heap_size);
            Heapify(A, 0, heap_size);     // 从新的堆顶元素开始向下进行堆调整，时间复杂度O(logn)
        }
    }
    
    int main()
    {
        int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大堆排序
        int n = sizeof(A) / sizeof(int);
        HeapSort(A, n);
        printf("堆排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }

## 8. 快速排序 ##
　　快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。
快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：

* 从序列中挑出一个元素，作为"基准"(pivot).
* 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。
* 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。

快速排序的代码如下：  

    #include <stdio.h>   
    void Swap(int A[], int i, int j)
    {
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
    }
    
    int Partition(int A[], int left, int right)  // 划分函数
    {
        int pivot = A[right];               // 这里每次都选择最后一个元素作为基准
        int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引
        for (int i = left; i < right; i++)  // 遍历基准以外的其他元素
        {
            if (A[i] <= pivot)              // 把小于等于基准的元素放到前一个子数组末尾
            {
                Swap(A, ++tail, i);
            }
        }
        Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组
                                            // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法
        return tail + 1;                    // 返回基准的索引
    }
    
    void QuickSort(int A[], int left, int right)
    {
        if (left >= right)
            return;
        int pivot_index = Partition(A, left, right); // 基准的索引
        QuickSort(A, left, pivot_index - 1);
        QuickSort(A, pivot_index + 1, right);
    }
    
    int main()
    {
        int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序
        int n = sizeof(A) / sizeof(int);
        QuickSort(A, 0, n - 1);
        printf("快速排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }
    
**快速排序分析**

* 时间复杂度   
　　每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2); 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)  
* 时间复杂度  
　　平均复杂度O(nlogn)，最差所需辅助空间主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)         
* 稳定性 
不稳定  

## 9. 计数排序 ##
　　如果在面试中有面试官要求你写一个O(n)时间复杂度的排序算法，你千万不要立刻说：这不可能！虽然前面基于比较的排序的下限是O(nlogn)。
但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。
其基本思想是，用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。  
　　计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。
通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。
计数排序的步骤如下：

* 统计数组A中每个值A[i]出现的次数，存入C[A[i]]
* 从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就变成了代表数组A中小于等于A[i]的元素个数
* 反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]个位置（下标为C[A[i]] - 1），每放一个元素就将C[A[i]]递减
                                    
计数排序的实现代码如下： 

    #include<iostream>
    using namespace std;
    
    // 分类 ------------ 内部非比较排序
    // 数据结构 --------- 数组
    // 最差时间复杂度 ---- O(n + k)
    // 最优时间复杂度 ---- O(n + k)
    // 平均时间复杂度 ---- O(n + k)
    // 所需辅助空间 ------ O(n + k)
    // 稳定性 ----------- 稳定
    
    
    const int k = 100;   // 基数为100，排序[0,99]内的整数
    int C[k];            // 计数数组
    
    void CountingSort(int A[], int n)
    {
        for (int i = 0; i < k; i++)   // 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)
        {
            C[i] = 0;
        }
        for (int i = 0; i < n; i++)   // 使C[i]保存着等于i的元素个数
        {
            C[A[i]]++;
        }
        for (int i = 1; i < k; i++)   // 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上
        {
            C[i] = C[i] + C[i - 1];
        }
        int *B = (int *)malloc((n) * sizeof(int));// 分配临时空间,长度为n，用来暂存中间数据
        for (int i = n - 1; i >= 0; i--)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)
        {
            B[--C[A[i]]] = A[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上
                                      // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性
        }
        for (int i = 0; i < n; i++)   // 把临时空间B中的数据拷贝回A
        {
            A[i] = B[i];
        }
        free(B);    // 释放临时空间 
    }
    
    int main()
    {
        int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素
        int n = sizeof(A) / sizeof(int);
        CountingSort(A, n);
        printf("计数排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }
    
　　计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此对于数据范围很大的数组，计数排序需要大量时间和内存。
例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。

## 10. 基数排序 ##
　　基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，
数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。
基数排序的实现代码如下：

    #include<iostream>
    using namespace std;
    
    // 分类 ------------- 内部非比较排序
    // 数据结构 ---------- 数组
    // 最差时间复杂度 ---- O(n * dn)
    // 最优时间复杂度 ---- O(n * dn)
    // 平均时间复杂度 ---- O(n * dn)
    // 所需辅助空间 ------ O(n * dn)
    // 稳定性 ----------- 稳定
    
    const int dn = 3;                // 待排序的元素为三位数及以下
    const int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数
    int C[k];
    
    int GetDigit(int x, int d)          // 获得元素x的第d位数字
    {
        int radix[] = { 1, 1, 10, 100 };// 最大为三位数，所以这里只要到百位就满足了
        return (x / radix[d]) % 10;
    }
    
    void CountingSort(int A[], int n, int d)// 依据元素的第d位数字，对A数组进行计数排序
    {
        for (int i = 0; i < k; i++)
        {
            C[i] = 0;
        }
        for (int i = 0; i < n; i++)
        {
            C[GetDigit(A[i], d)]++;
        }
        for (int i = 1; i < k; i++)
        {
            C[i] = C[i] + C[i - 1];
        }
        int *B = (int*)malloc(n * sizeof(int));
        for (int i = n - 1; i >= 0; i--)
        {
            int dight = GetDigit(A[i], d);  // 元素A[i]当前位数字为dight   
            B[--C[dight]] = A[i];           // 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上
            // 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性
        }
        for (int i = 0; i < n; i++)
        {
            A[i] = B[i];
        }
        free(B);
    }
    
    void LsdRadixSort(int A[], int n)     // 最低位优先基数排序
    {
        for (int d = 1; d <= dn; d++)     // 从低位到高位
            CountingSort(A, n, d);        // 依据第d位数字对A进行计数排序
    }
    
    int main()
    {
        int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入
        int n = sizeof(A) / sizeof(int);
        LsdRadixSort(A, n);
        printf("基数排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }

下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程：  
![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160329112725566-1371714328.jpg)  
　　基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），
和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。
如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，
而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。
由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。  

## 11. 桶排序 ##
桶排序的基本思想：
假设有一组长度为N的待排关键字序列K[1....n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，
将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。
接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]....B[M]中的全部内容即是一个有序序列。bindex=f(key)   
其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，
它必须做到：如果关键字k1<k2，那么f(k1)<=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。
很显然，映射函数的确定与数据本身的特点有很大的关系。
举个栗子：  
　　　　　　　　　　　　　　　　　　　　　　![](http://images2015.cnblogs.com/blog/735119/201603/735119-20160305144435034-1868814358.gif)  
　　假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。
则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。
桶排序分析：
桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，
归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。  
对N个关键字进行桶排序的时间复杂度分为两个部分：  

* 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。  
* 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为  ∑ O(Ni\*logNi) 。其中Ni 为第i个桶的数据量。    
很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N\*logN)了)。
因此，我们需要尽量做到下面两点：   
(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。  
(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，
数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。
对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：  
O(N)+O(M\*(N/M)\*log(N/M))=O(N+N\*(logN-logM))=O(N+N\*logN-N\*logM)    
当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。

　　总结：桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 
当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。 

    #include<iostream>
    using namespace std;
    
    // 分类 ------------- 内部非比较排序
    // 数据结构 --------- 数组
    // 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式
    // 最优时间复杂度 ---- O(n)，每个元素占一个桶
    // 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可
    // 所需辅助空间 ------ O(n + bn)
    // 稳定性 ----------- 稳定
    
    /* 本程序用数组模拟桶 */
    const int bn = 5;    // 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量
    int C[bn];           // 计数数组，存放桶的边界信息
    
    void InsertionSort(int A[], int left, int right)
    {
        for (int i = left + 1; i <= right; i++)  // 从第二张牌开始抓，直到最后一张牌
        {
            int get = A[i];
            int j = i - 1;
            while (j >= left && A[j] > get)
            {
                A[j + 1] = A[j];
                j--;
            }
            A[j + 1] = get;
        }
    }
    
    int MapToBucket(int x)
    {
        return x / 10;    // 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块
    }
    
    void CountingSort(int A[], int n)
    {
        for (int i = 0; i < bn; i++)
        {
            C[i] = 0;
        }
        for (int i = 0; i < n; i++)     // 使C[i]保存着i号桶中元素的个数
        {
            C[MapToBucket(A[i])]++;
        }
        for (int i = 1; i < bn; i++)    // 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置
        {
            C[i] = C[i] + C[i - 1];
        }
        int *B = (int *)malloc((n) * sizeof(int));
        for (int i = n - 1; i >= 0; i--)// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)
        {
            int b = MapToBucket(A[i]);  // 元素A[i]位于b号桶
            B[--C[b]] = A[i];           // 把每个元素A[i]放到它在输出数组B中的正确位置上
                                        // 桶的边界被更新：C[b]为b号桶第一个元素的位置
        }
        for (int i = 0; i < n; i++)
        {
            A[i] = B[i];
        }
        free(B);
    }
    
    void BucketSort(int A[], int n)
    {
        CountingSort(A, n);          // 利用计数排序确定各个桶的边界（分桶）
        for (int i = 0; i < bn; i++) // 对每一个桶中的元素应用插入排序
        {
            int left = C[i];         // C[i]为i号桶第一个元素的位置
            int right = (i == bn - 1 ? n - 1 : C[i + 1] - 1);// C[i+1]-1为i号桶最后一个元素的位置
            if (left < right)        // 对元素个数大于1的桶进行桶内插入排序
                InsertionSort(A, left, right);
        }
    }
    
    int main()
    {
        int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入
        int n = sizeof(A) / sizeof(int);
        BucketSort(A, n);
        printf("桶排序结果：");
        for (int i = 0; i < n; i++)
        {
            printf("%d ", A[i]);
        }
        printf("\n");
        return 0;
    }

下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程:  
![](http://images2015.cnblogs.com/blog/739525/201603/739525-20160329130428269-1682778397.jpg)  
桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。  

## 12. 参考资料 ##
[http://www.cnblogs.com/eniac12/p/5332117.html](http://www.cnblogs.com/eniac12/p/5332117.html)  
[https://www.cnblogs.com/wxisme/p/5243631.html](https://www.cnblogs.com/wxisme/p/5243631.html)  
[https://www.cnblogs.com/eniac12/p/5329396.html](https://www.cnblogs.com/eniac12/p/5329396.html)  

















