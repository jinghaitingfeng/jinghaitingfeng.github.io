---
layout:     post
title:      字符串处理函数
subtitle:   strcpy/strncpy/memcpy/memmove
date:       2018-1-4
author:     jinghaitingfeng
header-img: img/post-bg-os-metro.jpg
catalog: true
tags:
    - C/C++
    
---

## 1. strcpy ##
原型：   
　　　char * strcpy ( char * destination, const char * source )  
参数：

* destination指向`存储`待拷贝数据的地址，也就是目的地址  
* source指向待拷贝数据的地址，也就是源地址

返回值：  
　　　destination的地址，并且destination不一定为数组的首地址，可以通过+n来移动  
缺点：  
　　　不检查destination是否可以容纳下source的字符串，因此会造成buffer overflow  
　　　strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出或者截断  
函数实现： 

    char * strcpy(char * dest, const char * src)
    {
    　　if ((src == NULL) || (dest == NULL)) 
    　　{
     
    　　　　　　return NULL;
    　　}
    　　char *strdest = dest; 
    　　while ((*strDest++ = *strSrc++)!='\0'); 
    　　return strdest;
    }

使用举例： 

    /* strcpy example */
    #include <stdio.h>
    #include <string.h>
    
    int main ()
    {
      char str1[]="Sample string";
      char str2[40];
      char str3[40];
      strcpy (str2,str1);
      strcpy (str3,"copy successful");
      printf ("str1: %s\nstr2: %s\nstr3: %s\n",str1,str2,str3);
      return 0;
    }

Output:  
str1: Sample string  
str2: Sample string  
str3: copy successful 

## 2. strncpy ## 
原型：  
char * strncpy ( char * destination, const char * source, size_t num );  
函数说明：  
　　Copies the first num characters of source to destination. If the end of the source C string (which is signaled by a null-character) 
is found before num characters have been copied, destination is padded with zeros until a total of num characters have been written to it.  
　　No null-character is implicitly appended at the end of destination if source is longer than num. Thus, in this case,
destination shall not be considered a null terminated C string (reading it as such would overflow).   
　　destination and source shall not overlap.  
函数实现： 

    //A simple implementation of strncpy() might be:
    char* strncpy(char *dest, const char *src, size_t n){
        size_t i;
        for (i = 0 ; i < n && src[i] != '\0' ; i++)
            dest[i] = src[i];
        for ( ; i < n ; i++)
            dest[i] = '\0';//当src长度<n时，不足补‘\0’.   
        return dest;
    }
使用举例：

    /* strncpy example */
    #include <stdio.h>
    #include <string.h>
    
    int main ()
    {
      char str1[]= "To be or not to be";
      char str2[40];
      char str3[40];
    
      /* copy to sized buffer (overflow safe): */
      strncpy ( str2, str1, sizeof(str2) );
    
      /* partial copy (only 5 chars): */
      strncpy ( str3, str2, 5 );
      str3[5] = '\0';   /* null character manually added */
    
      puts (str1);
      puts (str2);
      puts (str3);
    
      return 0;
    }
Output:  
To be or not to be  
To be or not to be  
To be   

## 3. memcpy ##  
strcpy和memcpy都是标准C库函数，它们有下面的特点:

* strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。
* memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。  
* strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。
* 用途不同,通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy 

原型：  
void * memcpy ( void * destination, const void * source, size_t num );  
函数说明：  
Copy block of memory
Copies the values of num bytes from the location pointed to by source directly to the memory block pointed to by destination.

The underlying type of the objects pointed to by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data.

The function does not check for any terminating null character in source - it always copies exactly num bytes.

To avoid overflows, the size of the arrays pointed to by both the destination and source parameters, shall be at least num bytes, and should not overlap  
参数：  
destination:  
　　　Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.  
source:  
　　　Pointer to the source of data to be copied, type-casted to a pointer of type const void*.  
num:  
　　　Number of bytes to copy,size_t is an unsigned integral type.  
缺点：  
　　在src和dst存在内存重叠时无法正确返回，仅在无重叠时适用。  
函数实现：

    void *mymemcpy(void *dst,const void *src,size_t num)
    {
        assert((dst!=NULL)&&(src!=NULL));
              //assert（des>=src+num||src>dst+num）;
    	byte * psrc = (byte *)src;//byte 既为unsigned char类型
    	byte * pdst = (byte *)dst;
    	while(num-->0)*pdst++ = *psrc++;
    	return dst;
    }

使用举例： 

    /* memcpy example */
    #include <stdio.h>
    #include <string.h>
    
    struct {
      char name[40];
      int age;
    } person, person_copy;
    
    int main ()
    {
      char myname[] = "Pierre de Fermat";
    
      /* using memcpy to copy string: */
      memcpy ( person.name, myname, strlen(myname)+1 );
      person.age = 46;
    
      /* using memcpy to copy structure: */
      memcpy ( &person_copy, &person, sizeof(person) );
    
      printf ("person_copy: %s, %d \n", person_copy.name, person_copy.age );
    
      return 0;
    }

## 4. memmove ## 
**函数分析：**  
memcpy是把src指向的对象中的size个字符拷贝到dest所指向的对象中,返回指向结果对象的指针.   
memmove也是把src指向的对象中的size个字符拷贝到dest所指向的对象中,返回指向结果对象的指针,但这两个函数在处理内存区域重叠的方式不同.  


内存重叠问题是指目的地址和源内存空间,这两段内存空间有了交集,因而在使用memcpy进行内存复制操作时,这段重叠的内存空间会被破坏.
这种情况在应用程序级代码中一般不会出现的,而在驱动或内核级代码中要十分小心,尽量使用memmove函数.

memcpy对内存空间有要求的,dest和src所指向的内存空间不能重叠,否则复制的数据是错误的.下面具体讲解一下这个错误是如何产生的.  
如果内存空间布局入下图所示:  
![](http://www.linuxidc.com/upload/2013_06/130603095568531.gif)  
　　src所指向的内存空间后面部分数据被新拷贝的数据给覆盖了(也就是dest<=src+size).所以拷贝到最后,
原来的数据肯定不是原来的数据,拷贝的数据也不是想要的数据,使用memcpy函数可以得到错误的结果.  
如果内存空间布局入下图所示:  
![](http://www.linuxidc.com/upload/2013_06/130603095568532.gif)  
　　虽然原来的数据不再是原来的数据(dest+size>=src),但拷贝的数据是原来的数据,
使用memcpy函数可以得到正确的结果.因此,在使用memcpy这个函数之前,还需要做一个判断,
如果dest<=src你才能使用这个函数不过完全没有必要,你直接使用memmove函数就可以了.
memmove在拷贝之前就做了一个判断,如果dest <= src,就按照memcpy的思路拷贝,
如果dest>src怎么办呢,看函数,它是从后面往前拷贝,这样就能正确拷贝数据了.
根据上面的分析,理解下面的代码应该是一件很容易的事情.  

函数原型：  
void * memmove ( void * destination, const void * source, size_t num );  
函数说明：  
Move block of memory
Copies the values of num bytes from the location pointed by source to the memory block pointed by destination. Copying takes place as if an intermediate buffer were used, allowing the destination and source to overlap.

The underlying type of the objects pointed by both the source and destination pointers are irrelevant for this function; The result is a binary copy of the data.

The function does not check for any terminating null character in source - it always copies exactly num bytes.

To avoid overflows, the size of the arrays pointed by both the destination and source parameters, shall be at least num bytes.  
函数实现一：

    void * memmove(void *dest, const void *src, size_t count)
    {
        if (dest == NULL || src == NULL)
              return NULL;
        char *pdest = static_cast <char*>(dest);
        const char *psrc  = static_cast <const char*>(psrc);
        int n = count;
        
        if (pdest > psrc && pdest < psrc+count)
        {
            for (size_t i=n-1; i != -1; --i)
            {
                    pdest[i] = psrc[i];
            }
        }
        else
        {
            for (size_t i= 0; i < n; i++)
            {
                    pdest[i] = psrc[i];
            }
        }
        
        return dest;
    }

函数实现二：

    void *memmove(void *dest, const void *src, size_t count)
    {
            char *tmp;
           const char *s;
           if (dest <= src) {
                    tmp = dest;
                   s = src;
                   while (count--)
                           *tmp++ = *s++;
           } else {
                   tmp = dest;
                   tmp += count;
                   s = src;
                   s += count;
                   while (count--)
                           *--tmp = *--s;
           }
           return dest;
    }

使用举例：

    /* memmove example */
    #include <stdio.h>
    #include <string.h>
    
    int main ()
    {
      char str[] = "memmove can be very useful......";
      memmove (str+20,str+15,11);
      puts (str);
      return 0;
    }

## 5. 参考资料 ##
[http://www.cplusplus.com](http://www.cplusplus.com)  
[http://www.linuxidc.com/Linux/2013-06/85344.htm](http://www.linuxidc.com/Linux/2013-06/85344.htm)  
[https://www.cnblogs.com/houjun/p/4913216.html](https://www.cnblogs.com/houjun/p/4913216.html)  
[https://www.cnblogs.com/stoneJin/archive/2011/09/16/2179248.html](https://www.cnblogs.com/stoneJin/archive/2011/09/16/2179248.html)  